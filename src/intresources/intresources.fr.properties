# File containing internal localization messages used by 
# log comments, approval notifications and some exceptions in CESeCore.
#
# The keys should be sections into which module the message
# originates from, example raadmin.msg1 or keyrecovery.testmessage
#
# FRENCH VERSION
#
# Version: $Id: $

# This are resources only used with the test script
raadmin.testmsg       = Test fr-FR                        
raadmin.testparams    = Test {0} {1} {2} {3} {4} message {0} 

# Database protection resources
databaseprotection.errorverify = "La protection de ligne est mauvaise, elle devrait \u00eatre '{0}' (calcul\u00e9e) mais elle \u00e9tait '{1}' (en base de donn\u00e9es). Classe {2}, Identifiant de ligne (rowId) {3}."; 
databaseprotection.notokenwithid = Pas de token de protection de base de donn\u00e9es avec l'identifiant {0}.

# Backup resources
backup.notauthorized = L'administrateur '{0}' n'est pas authoris\u00e9 \u00e0 r\u00e9aliser une sauvegarde (backup).
restore.notauthorized = L'administrateur '{0}' n'est pas authoris\u00e9 \u00e0 r\u00e9aliser une restauration (restore).

# CA administration resources
caadmin.addedca = L'AC avec l'identifiant {0} et le nom {1} a \u00e9t\u00e9 ajout\u00e9e, statut \: {2}. 
caadmin.editedca = L'AC avec l'identifiant {0} et le nom {1} a \u00e9t\u00e9 modifi\u00e9e.
caadmin.removedca = L'AC avec l'identifiant {0} et le nom {1} a \u00e9t\u00e9 supprim\u00e9e.
caadmin.renamedca = L'AC avec le nom {0} et l'identifiant {1} a \u00e9t\u00e9 renomm\u00e9 en {2}.
caadmin.caexistsname = Une AC avec le m\u00eame nom {0} existe d\u00e9j\u00e0.
caadmin.caexistsid = Une AC avec le m\u00eame identifiant {0} existe d\u00e9j\u00e0.
caadmin.canotexistsid = L'AC avec l'identifiant {0} n'existe pas.
caadmin.canotexistsname = L'AC avec le nom {0} n'existe pas.
caadmin.notauthorizedtoca = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 g\u00e9rer l'AC {1}.
caadmin.notauthorizedtoaddca = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 ajouter l'AC {1}.
caadmin.notauthorizedtoeditca = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 modifier l'AC {1}.
caadmin.notauthorizedtoremoveca = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 supprimer l'AC avec l'identifiant {1}.
caadmin.notauthorizedtorenameca = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 renommer l'AC avec l'identifiant {1}.
caadmin.caexpired = L'AC {0} a expir\u00e9.
caadmin.canotyetvalid = L'AC {0} n'est pas encore valide.

# Authorization resources
authorization.admingroupadded = Le groupe d'administrateurs {0} a \u00e9t\u00e9 ajout\u00e9.
authorization.erroraddroleexists = Erreur lors de l'ajout du groupe d'administrateurs {0}, ce groupe existe d\u00e9j\u00e0.
authorization.errorrolenotexists = Le groupe d'administrateurs avec le nom {0} n'existe pas.
authorization.errorroleexists = Le groupe d'administrateurs avec le nom {0} existe d\u00e9j\u00e0.
authorization.admingroupremoved = Le groupe d'administrateurs {0} a \u00e9t\u00e9 supprim\u00e9.
authorization.admingrouprenamed = Le groupe d'administrateurs {0} a \u00e9t\u00e9 renomm\u00e9 en {1}.
authorization.accessrulesadded = Droits d'acc\u00e8s ajout\u00e9s au groupe d'administrateurs {0}.
authorization.accessrulesremoved = Droits d'acc\u00e8s supprim\u00e9s du groupe d'administrateurs {0}.
authorization.adminadded = Administrateur(s) ajout\u00e9(s) au groupe d'administrateurs {0}.
authorization.adminremoved = Suppression d'administrateurs du groupe d'administrateurs {0}.
authorization.errorcreateauthtree = Erreur lors de la cr\u00e9ation de AuthorizationTreeUpdateDataBean.
authorization.notauthorizedtoeditroles = L'administrateur {0} n'est pas autoris\u00e9 \u00e0 \u00e9diter le groupe d'administrateurs {1}.
authorization.notuathorizedtoresource = L'administrateur n'est pas autoris\u00e9 \u00e0 g\u00e9rer la resource {0}. Message : {1}.

# Certificate creation resources
createcert.popverificationfailed = La v\u00e9rification POP a \u00e9chou\u00e9.
createcert.nokeyinrequest = Pas de cl\u00e9 publique dans la demande.
createcert.canotfoundissuerusername = Impossible de trouver l'identifiant de l'AC depuis le DN \u00e9metteur '{0}' ou le nom d'utilisateur '{1}'.
createcert.canotactive = L'AC de signature {0} n'est pas active.
createcert.usertypeinvalid = L'utilisateur est marqu\u00e9 comme utilisateur invalide (USER_INVALID) : impossible de cr\u00e9er un certificat pour l'utilisateur '{0}'.
createcert.key_exists_for_another_user = L'utilisateur {0} n'est pas autorit\u00e9 \u00e0 utiliser la m\u00eame cl\u00e9 que le(s) utilisateur(s) {1} utilise(nt).
createcert.subjectdn_exists_for_another_user = L'utilisateur {0} n'est pas autoris\u00e9 \u00e0 utiliser le m\u00eame DN du sujet que le(s) utilisateur(s) {1} utilise(nt). Voir la directive 'Forcer l'unicit\u00e9 du DN' \u00e0 la rubrique \u00c9diter/cr\u00e9er des AC.
createcert.not_unique_certserialnumberindex = La personnalisation du num\u00e9ro de s\u00e9rie du certificat ne sera pas autoris\u00e9e, tant que l'index de (issuerDN,serialNumber) ne sera pas unique dans la table 'CertificateData'.
createcert.certprof_not_allowing_cert_sn_override = Le profil de certificats utilis\u00e9 ('{0}') n'autorise pas la surcharge du num\u00e9ro de s\u00e9rie du certificat.
createcert.cert_serial_number_allready_in_database = Il y a d\u00e9j\u00e0 un certificat stock\u00e9 dans la table 'CertificateData' avec le num\u00e9ro de s\u00e9rie '{0}'.
createcert.certprof_not_allowing_cert_sn_override_using_normal = Le num\u00e9ro de s\u00e9rie personnalis\u00e9 ('{0}') n'est pas autoris\u00e9 par le profil de certificats. Un num\u00e9ro de s\u00e9rie normal est utilis\u00e9.
createcert.errorcertprofilenotfound = Le profil de certificats ({0}) ne peut pas \u00eatre trouv\u00e9.
createcert.errorcertprofiletype = Profil de certificats ({0}) incorrect pour une entit\u00e9 finale. Seuls les profils de certificats de type "Certificat final" (END_USER) peuvent \u00eatre utilis\u00e9s pour le composant de signature.
createcert.errorcertprofilenotauthorized = Les donn\u00e9es de l'entit\u00e9 contiennent une AC, {0}, que le profil de certificats, {1}, n'est pas autoris\u00e9 \u00e0 utiliser.
createcert.unsupportedkeytype = Type de cl\u00e9s publiques non support\u00e9 ({0}) : seuls les types de cl\u00e9s RSA et ECDSA sont support\u00e9s.
createcert.illegalkeylength = Taille de cl\u00e9 invalide : {0}.
createcert.notauthorized = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 cr\u00e9er un certificat avec l'AC {1}.
createcert.errorbeyondmaxvalidity = Le param\u00e8tre de date de validit\u00e9 en aval (notAfter) de la demande ({0}) pour l'utilisateur '{1}' est plus longue que le maximum indiqu\u00e9 dans le profil de certificats ({2}) : ce qui n'est pas autoris\u00e9. La valeur du param\u00e8tre notAfter du profil de certificats est utilis\u00e9e.
createcert.limitingvalidity = Limitation de la validit\u00e9 du certificat, car la dur\u00e9e de validit\u00e9 demand\u00e9e ({0}) va au-del\u00e0 de la validit\u00e9 de l'AC ({1}).
createcert.errorinvalidcausality = La date de d\u00e9but ({0}) est situ\u00e9e apr\u00e9s la date de fin ({1}). Tentative de r\u00e9cup\u00e9ration des dates en les inversant.
createcert.errorinvalidstarttime = Ignorance de l'invalidit\u00e9 du format d'heure de d\u00e9but ({0}).
createcert.errorbeforecurrentdate = Le param\u00e8tre notBefore (pas avant) de la demande ({0}) pour l'utilisateur '{1}' antidate la date courante : ce qui n'est pas autoris\u00e9. La date et l'heure courante sont utilis\u00e9es \u00e0 la place.
createcert.errorbeyondtoolateexpiredate = La date d'expiration demand\u00e9e doit \u00eatre ant\u00e9rieure \u00e0 celle du param\u00e8tre 'ca.toolateexpiredate'. Date d'expiration du certificat '{0}'. ca.toolateexpiredate '{1}'.
createcert.invalidsignaturealg = L'algorithme de signature {0} ne fait pas partie des algorithmes de signature autoris\u00e9s.
createcert.illegalname = Le DN du sujet requ\u00eat\u00e9 est mal format\u00e9. Le nom mal format\u00e9 est seulement visible dans les journaux des traces.

# CRL creation resources
createcrl.createdcrl = Cr\u00e9ation de la LCR num\u00e9ro {0} pour l'AC '{1}' avec le DN '{2}'.
createcrl.errorcreate = Erreur lors de la cr\u00e9ation de la LCR pour l'AC {0}. Message : {1}.
createcrl.caoffline = L'AC {0}, {1} est hors ligne. La LCR ne peut pas \u00eatre g\u00e9n\u00e9r\u00e9e.
createcrl.errornotactive = L'AC {0}, {1} n'est pas active. La LCR ne peut pas \u00eatre cr\u00e9\u00e9e. Le statut est {2}.
createcrl.catokenoffline = Le token d'AC pour l'AC {0}, {1} est hors ligne. La LCR ne peut pas \u00eatre cr\u00e9\u00e9e.
createcrl.crlinfonull = Pas d'information disponible sur la LCR pour l'AC {0}. Utilisation du nombre 0 pour la prochaine mise \u00e0 jour (nextUpdate).
createcrl.generalerror = Erreur lors de la g\u00e9n\u00e9ration de la LCR pour l'AC {0}.
createcrl.erroravailcas = Erreur lors du listage des AC disponibles.
createcrl.notauthorized = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 cr\u00e9er de LCR pour l'AC {1}.

# Store resources
store.storecert = Certificat enregistr\u00e9 avec le nom '{0}', empreinte={1}, subjectDN '{2}', issuerDN '{3}', serialNo={4}.
store.revokedcert = Certificat r\u00e9voqu\u00e9 avec le nom '{0}', empreinte={1}, revocationReason={2}, subjectDN '{3}', issuerDN '{4}', serialNo={5}.
store.unrevokedcert = Certificat r\u00e9-activ\u00e9 avec le nom '{0}', empreinte={1}, revocationReason={2}, subjectDN '{3}', issuerDN '{4}, serialNo={5}.
store.ignorerevoke = Requ\u00eate du statut de r\u00e9vocation (setRevokeStatus()) num\u00e9ro : {0}, ignor\u00e9. Statut actuel du certificat : {1}. Raison de la r\u00e9vocation : {2}.
store.revokedallbyca = Tous les certificats d'AC de l'\u00e9metteur {0} r\u00e9voqu\u00e9s avec succ\u00e8s. Certificats {1} r\u00e9voqu\u00e9s de mani\u00e8re permanente pour la raison {2}.
store.errorrevokeallbyca = Erreur pendant la r\u00e9vocation de tous les certificats de l'AC \u00e9mis par par l'\u00e9metteur {0}.
store.errorfindcertfp  = Impossible de trouver le certificat avec l'empreinte {0} et le num\u00e9ro de s\u00e9rie {1}.
store.errorfindcertserno = Impossible de trouver le certificat avec le num\u00e9ro de s\u00e9rie {0}.
store.errorsetstatusargument = Le statut ne peut pas \u00eatre directement positionn\u00e9 \u00e0 R\u00c9VOQU\u00c9 (REVOKED) ni ACTIF (ACTIVE), utiliser plut\u00f4t la m\u00e9thode setRevokeStatus. Demande : empreinte={0}, statut={1}.
store.setstatus = Le statut a \u00e9t\u00e9 positionn\u00e9 pour le certificat avec le nom '{0}', empreinte={1}, statut={2}, subjectDN '{3}', issuerDN '{4}, serialNo={5}.
store.setstatusfailed = Tentative de positionnement du statut {0} pour le certificat avec l'empreinte {1}, qui n'existe pas.
store.storecrl = Enregistrement de la LCR avec le num\u00e9ro {0}, empreinte={1}, issuerDN '{2}'.
store.errorstorecrl = Erreur d'enregistrement de la LCR avec le num\u00e9ro {0}, issuerDN '{1}'.  
store.errorstorecrlwrongnumber = Tentative d'enregistrement de la LCR ayant le num\u00e9ro {0}, mais une LCR avec le num\u00e9ro {1} existe d\u00e9j\u00e0 pour l'\u00e9metteur dont le DN est '{2}'.
store.getcrl = Acc\u00e8s \u00e0 la LCR depuis l'\u00e9metteur {0} avec le num\u00e9ro de LCR {1}.
store.errorgetcrl = Erreur d'acc\u00e8s \u00e0 la LCR de l'\u00e9metteur {0} avec le num\u00e9ro de LCR {1}.
store.errorgetcrlinfo = Erreur d'acc\u00e8s aux informations de la LCR de l'\u00e9metteur {0}.
store.removedcrl = Suppression de la LCR avec l'empreinte={0} et le num\u00e9ro {1} pour l'\u00e9metteur dont le DN est '{2}'.
store.errorstorecert = Erreur lors de l'enregistrement du certificat.
store.errorcertinfo = Impossible de trouver le certificat avec l'empreinte {0}.
store.errorfindcertuser = Impossible de trouver le certificat avec le nom {0}.
store.errorseveralissuerserno = Erreur possible dans la base de donn\u00e9es : il existe plus d'un certificat avec le m\u00eame \u00e9metteur : {0} et le m\u00eame num\u00e9ro de s\u00e9rie : {1}, est-ce des certificats CVC ?
store.errorcertprofilefixed = Erreur durant le traitement du profil de certificats {0} : nom d'un profil fixe (FIXED).
store.errorcertprofileexists = Le profil de certificats {0} existe d\u00e9j\u00e0.
store.errorcertprofilenotexist = Le profil de certificats {0} n'existe pas.
store.addedcertprofile = Le nouveau profil de certificats {0} a \u00e9t\u00e9 cr\u00e9\u00e9.
store.editcertprofilenotauthorized = L'administrateur '{0}' n'est pas autoris\u00e9 \u00e0 \u00e9diter le profil de certificats {1}.
store.errorcreatecertprofile = Erreur pendant la cr\u00e9ation du nouveau profil de certificats {0}.
store.erroraddprofilewithtempl = Erreur durant l'ajout d'un profil de certificats {0} utilisant le profil {1} comme mod\u00e8le.
store.addedprofilewithtempl = Le nouveau profil de certificats {0} a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir du profil existant {1} comme mod\u00e8le.
store.removedprofile = Profil de certificats {0} supprim\u00e9.
store.errorremoveprofile = Erreur pendant la suppression du profil de certificats {0}.
store.renamedprofile = Profil de certificats {0} renomm\u00e9 en {1}.
store.errorrenameprofile = Erreur pendant le renommage du profil de certificats {0} en {1}.
store.editedprofile = Profil de certificats {0} modifi\u00e9.
store.erroreditprofile = Erreur pendant la modification du profil de certificats {0}.

# Miscellaneous resources
sernogenerator.discarding = Suppression des num\u00e9ros de s\u00e9rie hors de la plage de valeurs.

# Crypto and CA tokens in CESeCore
token.createdtoken = Cr\u00e9ation du token cryptographique avec le nom de classe {0} et l'identifiant ID={1}.
token.extractablekey = Une cl\u00e9 mat\u00e9rielle ne doit pas \u00eatre exportable. Vous pouvez positionner ca.doPermitExtractablePrivateKeys=true dans ejbca.properties pour autoriser les cl\u00e9s exportables. ca.doPermitExtractablePrivateKeys={0}.
token.noprivate = La cl\u00e9 priv\u00e9e avec l'alias '{0}' ne peut pas \u00eatre lue dans le magasin de cl\u00e9s. Retour nul. Si la cl\u00e9 a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e apr\u00e8s le dernier d\u00e9marrage du serveur d'applications, alors red\u00e9marrer le serveur d'applications.
token.nopublic = La cl\u00e9 publique avec l'alias '{0}' ne peut pas \u00eatre lue dans le magasin de cl\u00e9s. Retour nul. Si la cl\u00e9 a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e apr\u00e8s le dernier d\u00e9marrage du serveur d'applications, alors red\u00e9marrer le serveur d'applications.
token.nopinencrypt = \u00c9chec de chiffrement du code PIN d'auto-activation. Utilisation d'un code non chiffr\u00e9 \u00e0 la place :
token.jceinitfail = \u00c9chec d'initialisation du provider JCE. Les op\u00e9rations de chiffrement ne fonctionneront probablement pas, mais le processus continue...
token.errornosuchkey = Pas de cl\u00e9 avec l'alias '{0}'.
token.inforegisterclasspath = Impossible d'enregistrer {0}. Ce n'est habituellement pas une erreur.
token.classnotfound = Classe non trouv\u00e9e : {0}.
token.errorinstansiate = Impossible de lancer une instance de {0}. {1}.
token.deactivate = D\u00e9sactivation du token cryptographique d'identifiant ID={0}.
token.activated = Activation du token cryptographique d'identifiant ID={0}.
token.erroractivate = Erreur durant l'activation du token cryptographique d'identifiant ID={0}. {1}.
token.wrongauthcode = Code d'authentification invalide. Token ID={0}.
token.errorcreatetoken = Erreur lors de la cr\u00e9ation du token cryptographique. Token ID={0}.
token.deleteentry = Suppression de l'entr\u00e9e avec l'alias '{0}' du token avec l'identifiant ID={1}.
token.errorcertreqverify = La requ\u00eate de certificat n'est pas v\u00e9rifi\u00e9e.
token.errorkeynottoken = La cl\u00e9 avec l'empreinte de cl\u00e9 publique {0} n'est pas sur le token.
token.errornokeyalias = L'alias de cl\u00e9 '{0}' n'a pas \u00e9t\u00e9 trouv\u00e9 dans le magasin de cl\u00e9s.
token.errornocertalias = L'alias de certificat '{0}' n'a pas \u00e9t\u00e9 trouv\u00e9 dans le magasin de certificats.
token.authcodemissing = Un code d'authentification doit \u00eatre fourni. La g\u00e9n\u00e9ration ou l'activation de nouvelles cl\u00e9s requi\u00e8re soit un mot de passe en argument soit le mode auto-activation actif. Token ID={0}.
token.activationtestfail = Erreur de test d'activation pour le token cryptographique d'identifiant ID={0}.
token.upgrade = Mise \u00e0 jour du token cryptographique avec la version {0}.
token.generatedkeypair = G\u00e9n\u00e9ration de la bicl\u00e9 avec la sp\u00e9cification {0} et l'alias '{1}' pour le token cryptographique avec l'identifiant ID={2}.
token.generatedsymkey = G\u00e9n\u00e9ration d'une nouvelle cl\u00e9 sym\u00e9trique avec l'algorithme {0}, la taille {1} et l'alias '{2}' pour le token cryptographique avec l'identifiant ID={3}.
token.errornotextractable = Le token cryptographique ne permet pas l'extraction de cl\u00e9s priv\u00e9es. Les cl\u00e9s priv\u00e9es d'alias {0} et de chiffrement d'alias {1}, demand\u00e9es.

# CA token resources
catoken.generatedkeys = De nouvelles cl\u00e9s ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9es pour l'AC avec l'identifiant {0}, renew={1}, activate={2}.
catoken.activatednextkey = Activation de la prochaine signature de cl\u00e9 pour le token cryptographique d'identifiant {0}.
catoken.activated = Activation du token cryptographique d'identifiant {0}.
catoken.deactivated = D\u00e9sactivation du token cryptographique d'identifiant {0}.
catoken.setproperty = Positionnement de la propri\u00e9t\u00e9 du token d'AC pour l'AC avec : ID={0}, cl\u00e9={1}, valeur={2}.

# OCSP resources
ocsp.receivedunidreq = Demande re\u00e7ue de (IP,FQDN) : {0},{1} pour Fnr correspondant \u00e0 Unid={2}.
ocsp.errordatabaseunid = R\u00e9ception d'une erreur de base de donn\u00e9es en recherchant une source de donn\u00e9es pour Unid-Fnr.
ocsp.errorunidnosnindn = Impossible de trouver un num\u00e9ro de s\u00e9rie dans le DN '{0}'.
ocsp.errorunidnosnmapping = Aucune correspondance de Fnr existante pour UNID {0}.
ocsp.returnedunidresponse = R\u00e9ponse retourn\u00e9e \u00e0 (IP,FQDN) : {0},{1} avec Fnr={2} pour Unid={3}.
ocsp.errornoclientauth = Requ\u00eate re\u00e7ue sans authentification client de (IP,FQDN) : {0},{1}.
ocsp.errorverifycert = Erreur en essayant de v\u00e9rifier le certificat client.
ocsp.erroruntrustedclientauth = Requ\u00eate re\u00e7ue avec un certificat client de (IP,FQDN) : {0},{1}.
ocsp.errornoinitparam = Le param\u00e8tre d'initialisation {0} doit \u00eatre positionn\u00e9.
ocsp.errornotrustfiles = Pas de fichier dans le r\u00e9pertoire trustDir : {0}.
ocsp.errorreadingtrustfiles = Erreur de lecture des fichiers dans trustDir : {0}.
ocsp.errorreadingfile = Erreur de lecture {0} depuis {1} : {2}.
ocsp.certcollectionempty = La collection de certificats adress\u00e9e est vide.
ocsp.errorcomparehash = Exception de type OCSPexception durant la comparaison des empreintes des certificats. AC non prise en compte pour '{0}'.
ocsp.nomatchingcacert = Impossible de trouver le certificat d'AC correspondant au DN : {0}.
ocsp.reloadkeys = Rechargement de la cl\u00e9 due \u00e0 une requ\u00eate provenant de {0}.
ocsp.errorunsignedreq = Requ\u00eate OCSP non sign\u00e9e. Le servlet impose la signature.
ocsp.errorinvalidsignature = La signature des requ\u00eates OCSP (OCSPRequest) est invalide.
ocsp.infosigner = La requ\u00eate OCSP (OCSPRequest) a \u00e9t\u00e9 sign\u00e9e par '{0}'.
ocsp.infosigner.invalidcertsignature = V\u00e9rification du certificat du signataire pour (DN du sujet '{0}', DN de l'\u00e9metteur '{1}') \u00e9chou\u00e9e. Message : {2}. 
ocsp.infosigner.certnotyetvalid = Le certificat de signature OCSP n'est pas encore valide pour (DN du sujet '{0}', DN de l'\u00e9metteur '{1}'). Message : {2}.
ocsp.infosigner.certexpired = Le certificat de signature OCSP est expir\u00e9 pour (DN du sujet '{0}', DN de l'\u00e9metteur '{1}'). Message : {2}.
ocsp.infosigner.nocacert = Pas de certificat d'AC trouv\u00e9 pour le certificat de signature OCSP avec le DN du sujet '{0}' et le DN de l'\u00e9metteur '{1}'.
ocsp.infosigner.revoked = Le certificat de signature OCSP pour '{0}' est r\u00e9voqu\u00e9. DN de l'\u00e9metteur '{1}', num\u00e9ro de s\u00e9rie {2}.
ocsp.infosigner.notallowed = Le certificat de signature OCSP pour '{0}' n'est pas autoris\u00e9 \u00e0 cause de restrictions li\u00e9es au signataire ou \u00e0 l'\u00e9metteur. DN de l'\u00e9metteur '{1}', num\u00e9ro de s\u00e9rie {2}.
ocsp.errornoreqentities = La requ\u00eate OCSP ne contient aucune entit\u00e9 de type requ\u00eate simple (simpleRequest).
ocsp.errortoomanyreqentities = La requ\u00eate OCSP contient trop d'entit\u00e9s de type requ\u00eate simple (simpleRequest). Maximum autoris\u00e9 : {0}.
ocsp.errorgencerthash = Impossible de g\u00e9n\u00e9rer l'empreinte du certificat d'AC.
ocsp.errorfindcacert = Impossible de trouver le certificat par le biais de l'empreinte de l'\u00e9metteur {0}, ni le r\u00e9pondeur par d\u00e9faut {1}.
ocsp.errorfindcacertusedefault = Impossible de trouver le certificat par le biais de l'empreinte de l'\u00e9metteur {0}. Utilisation du r\u00e9pondeur par d\u00e9faut pour envoyer le message \u00ab UnknownStatus \u00bb.
ocsp.errorprocessextension = Une erreur s'est produite durant le traitement de la classe d'extension OCSP : {0}. Code d'erreur : {1}.
ocsp.errornocacreateresp = Impossible de trouver le certificat et la cl\u00e9 d'AC pour g\u00e9n\u00e9rer la r\u00e9ponse OCSP.
ocsp.errorprocessreq = Erreur de traitement d'une requ\u00eate OCSP. Message : {0}.
ocsp.classnotfound = La classe {0} ne peut pas \u00eatre charg\u00e9e.
ocsp.nocardpwd = Pas de mot de passe de carte sp\u00e9cifi\u00e9.
ocsp.nohwsigningclass = Pas de classe de signature OCSP mat\u00e9riel d\u00e9finie.
ocsp.errornosignkeys = Aucune cl\u00e9 de signature valide n'est disponible \u00e0 cet instant.
ocsp.errornovalidkeys = Pas de cl\u00e9 valide sp\u00e9cifi\u00e9e.
ocsp.errorinitialize = Incapable d'initialiser la servlet OCSP (OCSPServlet).
ocsp.signcertnotindb = Impossible de trouver le certificat de signature avec le num\u00e9ro de s\u00e9rie {0} de l'\u00e9metteur {1} dans la base de donn\u00e9es (la signature et le certificat d'AC doivent \u00eatre publi\u00e9s dans le r\u00e9pondeur OCSP).
ocsp.signcertrevoked = Certificat de signature avec le num\u00e9ro de s\u00e9rie {0} de l'\u00e9metteur {1} r\u00e9voqu\u00e9.
ocsp.signcerthasnochain = Pas de cha\u00eene de certification jusqu'\u00e0 une AC racine pour le certificat signataire avec le num\u00e9ro de s\u00e9rie {0} et \u00e9mis par l'\u00e9metteur {1}.
ocsp.errorgetalias = Impossible d'obtenir l'alias {0} dans le fichier {1}.
ocsp.newsigningkey = Nouvelle cl\u00e9 de signature OCSP pour l'AC '{0}'. Certificat {1}.
ocsp.errorocspkeynotusable = Cl\u00e9 de signature OCSP non utilisable pour l'AC {0}. Certificat avec le num\u00e9ro de s\u00e9rie : {1}.
ocsp.errorloadsigningcerts = Impossible de charger les certificats de signature.
ocsp.infoaddedstatusinfo = Ajout de l'information de statut {0} pour le certificat avec le num\u00e9ro de s\u00e9rie {1} et \u00e9mis par l'\u00e9metteur {2}.
ocsp.inforeceivedrequest = Requ\u00eate OSCP re\u00e7ue pour le certificat avec le num\u00e9ro de s\u00e9rie {0} et l'empreinte du nom de l'\u00e9metteur {1}. Adresse IP du client : {2}.
ocsp.toolarge = Requ\u00eate ignor\u00e9e. OCSP supporte seulement les requ\u00eates de {0} octets au plus. L'actuelle requ\u00eate \u00e9tait de {1} octets.
ocsp.badurlenc = Codage incorrect de l'URL dans la requ\u00eate.
ocsp.missingreq = La derni\u00e8re partie de l'URL est manquante dans la requ\u00eate (cf. RFC 2560, \u00a7 A.1.1).
ocsp.unknownmethod = M\u00e9thode de requ\u00eate inconnue '{0}'. Seules les m\u00e9thodes GET et POST sont support\u00e9es.
ocsp.emptyreq = Requ\u00eate vide: aucun octet re\u00e7u depuis l'adresse IP {0}.
ocsp.shrinkmaxage = RFC 5019, \u00a7 6.2 : la date ultime devrait \u00eatre 'ult\u00e9rieure \u00e0 thisUpdate et ant\u00e9rieure \u00e0 nextUpdate'. R\u00e9duire la date ultime (maxAge) \u00e0 la plus grande valeur possible '{0}'.
ocsp.additionaldata = La requ\u00eate OCSP \u00e9tait cod\u00e9e sur '{0}' octets, mais la valeur de HTTP Content-length \u00e9tait de '{1}' octets. Le client OCSP est peut-\u00eatre cass\u00e9 ou essaie de vous envoyer trop de donn\u00e9es.
ocsp.errorcerthasexpired = Le certificat de signature OCSP avec le num\u00e9ro de s\u00e9rie '{0}' \u00e9mis par l'AC '{1}' a expir\u00e9.
ocsp.errornotyetvalid = Le certificat de signature OCSP avec le num\u00e9ro de s\u00e9rie '{0}' \u00e9mis par l'AC '{1}' n'est pas encore valide.
ocsp.warncertwillexpire = Le certificat de signature OCSP avec le num\u00e9ro de s\u00e9rie '{0}' \u00e9mis par l'AC '{1}' va expirer le '{2}'.

# Request resources
request.toolarge = Requ\u00eate ignor\u00e9e. Seules les requ\u00eates de {0} octets ou moins sont support\u00e9es. La requ\u00eate actuelle avait {1} octets. 
request.notasequence = Pas de s\u00e9quence au niveau sup\u00e9rieur. La balise (tag) \u00e9tait {0}.
request.notcorrectasn1length = Le message n'a pas la bonne longueur selon la longueur ASN.1 de la balise (tag). La longueur de la balise (tag) \u00e9tait {0}, mais seulement {1} octets ont \u00e9t\u00e9 lus.

# X.509v3 certificate extension
certext.errorparsingproperty= Erreur durant l'analyse du fichier 'certextensions.properties'.
certext.certextmissconfigured = Les extensions de certificat {0} semblent \u00eatre mal configur\u00e9es dans le fichier 'certextensions.properties'.
certext.noextensionforid = Pas d'extension configur\u00e9e pour l'identifiant {0}. R\u00e9ponse nulle retourn\u00e9e.
certext.basic.incorrectvalue = Propri\u00e9t\u00e9 'valeur' incorrect pour l'extension basique de certificat avec l'identifiant {0} and OID : {1}.
certext.basic.incorrectenc = Codage incorrect ({0}) pour l'extension basique de certificat avec l'identifiant {1}.
certext.basic.illegalvalue = Valeur ill\u00e9gale {0} pour l'extension basique de certificat avec l'identifiant {1} et OID : {2}.

# General error messages, used in several places
error.catokenoffline = Le token d'AC {0} est hors ligne.
error.caoffline = L'AC '{0}' n'est pas active. Statut de l'AC={1}.

# EOF
