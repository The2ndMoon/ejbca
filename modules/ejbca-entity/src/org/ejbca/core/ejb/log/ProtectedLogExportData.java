/*************************************************************************
 *                                                                       *
 *  EJBCA: The OpenSource Certificate Authority                          *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.log;

import java.io.Serializable;
import java.util.Collection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.Query;
import javax.persistence.Table;
import javax.persistence.Transient;

import org.ejbca.util.Base64;
import org.ejbca.util.GUIDGenerator;

/**
 * Representation of a ProtectedLogExport in the database.
 * 
 * @version $Id$
 */
@Deprecated
@Entity
@Table(name="ProtectedLogExportData")
public class ProtectedLogExportData implements Serializable {

	private static final long serialVersionUID = 1L;
	//private static final Logger log = Logger.getLogger(ProtectedLogExportData.class);

	private String pk;
	private long timeOfExport;
	private long exportEndTime;
	private long exportStartTime;
	private String b64LogDataHash;
	private String b64PreviosExportHash;
	private String currentHashAlgorithm;
	private String b64SignatureCertificate;
	private boolean deleted;
	private String b64Signature;

	/**
	 * Entity Bean holding data of a service configuration.
	 */
	public ProtectedLogExportData(long timeOfExport, long exportEndTime, long exportStartTime, byte[] logDataHash, byte[] previosExportHash, String currentHashAlgorithm,
			byte[] signatureCertificate, boolean deleted, byte[] signature) {
		setPk(GUIDGenerator.generateGUID(this));
		setTimeOfExport(timeOfExport);
	    setExportEndTime(exportEndTime);
	    setExportStartTime(exportStartTime);
	    setLogDataHash(logDataHash);
	    setPreviosExportHash(previosExportHash);
	    setCurrentHashAlgorithm(currentHashAlgorithm);
	    setSignatureCertificate(signatureCertificate);
	    setDeleted(deleted);
	    setSignature(signature);
	}

	public ProtectedLogExportData() { }

	/** Primary Key. A 32 byte GUID generated by org.ejbca.util.GUIDGenerator. */
	@Id
	@Column(name="pk")
	public String getPk() { return pk; }
	public void setPk(String pk) { this.pk = pk; }

	/** The time when the export was done. */
	@Column(name="timeOfExport", nullable=false)
    public long getTimeOfExport() { return timeOfExport; }
    public void setTimeOfExport(long timeOfExport) { this.timeOfExport = timeOfExport; }
    
    /** The newest event for this export. */
	@Column(name="exportEndTime", nullable=false)
    public long getExportEndTime() { return exportEndTime; }
    public void setExportEndTime(long exportEndTime) { this.exportEndTime = exportEndTime; }

    /** The oldest event for this export. */
	@Column(name="exportStartTime", nullable=false)
    public long getExportStartTime() { return exportStartTime; }
    public void setExportStartTime(long exportStartTime) { this.exportStartTime = exportStartTime; }
    
    /** The hashed log-related data. */
	@Column(name="b64LogDataHash")
    public String getB64LogDataHash() { return b64LogDataHash; }
    public void setB64LogDataHash(String b64LogDataHash) { this.b64LogDataHash = b64LogDataHash; }

	@Transient
	public byte[] getLogDataHash() {
    	String b64LogDataHash = getB64LogDataHash();
    	if (b64LogDataHash == null) {
    		return null;
    	}
    	return Base64.decode(b64LogDataHash.getBytes());
    }

    public void setLogDataHash(byte[] data) {
    	if (data == null) {
    		setB64LogDataHash(null);
    	} else {
            setB64LogDataHash(new String(Base64.encode(data, false)));
    	}
    }
    
    /** The hash of the previous export. */
	@Column(name="b64PreviosExportHash")
    public String getB64PreviosExportHash() { return b64PreviosExportHash; }
    public void setB64PreviosExportHash(String b64PreviosExportHash) { this.b64PreviosExportHash = b64PreviosExportHash; }

	@Transient
    public byte[] getPreviosExportHash() {
    	String b64PreviosExportHash = getB64PreviosExportHash();
    	if (b64PreviosExportHash == null) {
    		return null;
    	}
        return Base64.decode(b64PreviosExportHash.getBytes());
    }

    public void setPreviosExportHash(byte[] data) {
    	if (data == null) {
    		setB64PreviosExportHash(null);
    	} else {
            setB64PreviosExportHash(new String(Base64.encode(data, false)));
    	}
    }
    
    /** The used hash algorithm. */
	@Column(name="currentHashAlgorithm")
    public String getCurrentHashAlgorithm() { return currentHashAlgorithm; }
    public void setCurrentHashAlgorithm(String currentHashAlgorithm) { this.currentHashAlgorithm = currentHashAlgorithm; }
    
    /** The certificate that corresponds to the signing key. */
	@Column(name="b64SignatureCertificate")
	@Lob
    public String getB64SignatureCertificate() { return b64SignatureCertificate; } 
    public void setB64SignatureCertificate(String b64SignatureCertificate) { this.b64SignatureCertificate = b64SignatureCertificate; }

	@Transient
    public byte[] getSignatureCertificate() {
    	String b64SignatureCertificate = getB64SignatureCertificate();
    	if (b64SignatureCertificate == null) {
    		return null;
    	}
        return Base64.decode(b64SignatureCertificate.getBytes());
    }

    public void setSignatureCertificate(byte[] data) {
    	if (data == null) {
    		setB64SignatureCertificate(null);
    	} else {
            setB64SignatureCertificate(new String(Base64.encode(data, false)));
    	}
    }

    /** If the LogEvents were removed after the export. */
	@Column(name="deleted", nullable=false)
    public boolean getDeleted() { return deleted; }
    public void setDeleted(boolean deleted) { this.deleted = deleted; }

    /** The signature of all the previous columns (except pk). */
	@Column(name="b64Signature")
	@Lob
    public String getB64Signature() { return b64Signature; }
    public void setB64Signature(String b64Signature) { this.b64Signature = b64Signature; }

	@Transient
    public byte[] getSignature() {
    	String b64Signature = getB64Signature();
    	if (b64Signature == null) {
    		return null;
    	}
        return Base64.decode(b64Signature.getBytes());
    }

    public void setSignature(byte[] data) {
    	if (data == null) {
    		setB64Signature(null);
    	} else {
            setB64Signature(new String(Base64.encode(data, false)));
    	}
    }

	//
	// Search functions. 
	//

	public static ProtectedLogExportData findByPk(EntityManager entityManager, String pk) {
		return entityManager.find(ProtectedLogExportData.class,  pk);
	}

	public static ProtectedLogExportData findByExportStartTime(EntityManager entityManager, long exportStartTime) {
		Query query = entityManager.createQuery("from ProtectedLogExportData a WHERE a.exportStartTime=:exportStartTime");
		query.setParameter("exportStartTime", exportStartTime);
		return (ProtectedLogExportData) query.getSingleResult();
	}    

	public static Collection<ProtectedLogExportData> findAll(EntityManager entityManager) {
		Query query = entityManager.createQuery("from ProtectedLogExportData a");
		return query.getResultList();
	}    
}
