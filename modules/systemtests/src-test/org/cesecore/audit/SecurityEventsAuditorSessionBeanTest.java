/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.audit;

import static junit.framework.Assert.assertTrue;
import static org.cesecore.util.QueryCriteria.where;
import static org.junit.Assert.assertNotNull;

import java.io.File;
import java.security.KeyPair;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.security.auth.x500.X500Principal;

import org.cesecore.audit.audit.AuditLogReportElem;
import org.cesecore.audit.audit.AuditLogValidationReport;
import org.cesecore.audit.audit.AuditLogValidatorException;
import org.cesecore.audit.audit.SecurityEventsAuditorSession;
import org.cesecore.audit.audit.SecurityEventsAuditorSessionRemote;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.X509CertificateAuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.CertTools;
import org.cesecore.jndi.JndiHelper;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.CryptoProviderTools;
import org.cesecore.util.QueryCriteria;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Security auditor logs auditor functional tests;
 * 
 * Based on cesecore version:
 *      SecurityEventsAuditorSessionBeanTest.java 929 2011-07-05 11:54:28Z johane
 * 
 * @version $Id$
 * 
 */
public class SecurityEventsAuditorSessionBeanTest extends SecurityEventsBase {

    private SecurityEventsAuditorSession securityEventsAuditor = JndiHelper.getRemoteSession(SecurityEventsAuditorSessionRemote.class);

    private static KeyPair keys;

    @BeforeClass
    public static void setUpCryptoProvider() throws Exception {
        CryptoProviderTools.installBCProvider();

        keys = KeyTools.genKeys("512", AlgorithmConstants.KEYALGORITHM_RSA);
    }

    @Test
    public void test02SelectLogsWithCriteria() throws AuthorizationDeniedException {
        for (final String logDeviceId : securityEventsAuditor.getQuerySupportingLogDevices()) {
            final List<? extends AuditLogEntry> list = securityEventsAuditor.selectAuditLogs(roleMgmgToken, 1, 10,
                    where().eq(AuditLogEntry.FIELD_AUTHENTICATION_TOKEN, "userid"), logDeviceId);
            assertTrue(list.size() >= 0);
        }
    }

    @Test
    public void test03SelectLogsWithNullCriteria() throws AuthorizationDeniedException {
        for (final String logDeviceId : securityEventsAuditor.getQuerySupportingLogDevices()) {
            final List<? extends AuditLogEntry> list = securityEventsAuditor.selectAuditLogs(roleMgmgToken, 1, 10, null, logDeviceId);
            assertTrue(list.size() >= 0);
        }
    }

    /**
     * Validates existing audit logs since DB will always have audit logs (at least the ones generated by exports)
     */
    @Test
    public void test04AuditLogsValidation() throws AuditLogValidatorException, AuthorizationDeniedException {
        for (final String logDeviceId : securityEventsAuditor.getQuerySupportingLogDevices()) {
            final AuditLogValidationReport report = securityEventsAuditor.verifyLogsIntegrity(roleMgmgToken, new Date(), logDeviceId);
            assertNotNull(report);
            final StringBuilder strBuilder = new StringBuilder();
            strBuilder.append("logDevice: ").append(logDeviceId).append("\n");
            for (final AuditLogReportElem error : report.errors()) {
                strBuilder.append(String.format("invalid sequence: %d %d\n", error.getFirst(), error.getSecond()));
                for (final String reason : error.getReasons())
                    strBuilder.append(String.format("Reason: %s\n", reason));
            }
            assertTrue("validation report: " + strBuilder.toString(), (report.warnings().size() == 1 || report.warnings().size() == 0)
                    && report.errors().size() == 0);
        }
    }

    @Test
    public void test05ExportLogs() throws Exception {
        final CryptoToken cryptoToken = createTokenWithKeyPair();
        for (final String logDeviceId : securityEventsAuditor.getQuerySupportingLogDevices()) {
            String file0 = securityEventsAuditor.exportAuditLogs(roleMgmgToken, cryptoToken, new Date(), false, keyAlias, keyPairSignAlgorithm,
                    logDeviceId).getExportedFile();
            File f0 = new File(file0);
            long length0 = f0.length();
            // System.out.println(length0);
            assertTrue("file does not exist, " + f0.getAbsolutePath(), f0.exists());
            assertTrue("file length is not > 0, " + f0.getAbsolutePath(), length0 > 0);
            assertTrue("file can not be deleted, " + f0.getAbsolutePath(), f0.delete());
            // Doing it again, but deleting logs after export this time
            String file1 = securityEventsAuditor.exportAuditLogs(roleMgmgToken, cryptoToken, new Date(), true, keyAlias, keyPairSignAlgorithm,
                    logDeviceId).getExportedFile();
            File f1 = new File(file1);
            long length1 = f1.length();
            // System.out.println(length1);
            assertTrue("file does not exist, " + f1.getAbsolutePath(), f1.exists());
            assertTrue("file length is not > 0, " + f1.getAbsolutePath(), length1 > 0);
            assertTrue("f1 length is not >= f0 length", length1 >= length0);
            assertTrue("file can not be deleted, " + f1.getAbsolutePath(), f1.delete());
            // Doing it again should give less result, since logs have been deleted
            String file2 = securityEventsAuditor.exportAuditLogs(roleMgmgToken, cryptoToken, new Date(), true, keyAlias, keyPairSignAlgorithm,
                    logDeviceId).getExportedFile();
            File f2 = new File(file2);
            long length2 = f2.length();
            // System.out.println(length2);

            assertTrue("file does not exist, " + f2.getAbsolutePath(), f2.exists());
            assertTrue("file length is not > 0, " + f2.getAbsolutePath(), length2 > 0);

            assertTrue("file can not be deleted, " + f2.getAbsolutePath(), f2.delete());
        }
    }

    @Test
    public void test06Authorization() throws Exception {
        final X509Certificate certificate = CertTools.genSelfCert("C=SE,O=Test,CN=Test LogMgmtSessionNoAuth", 365, null, keys.getPrivate(),
                keys.getPublic(), AlgorithmConstants.SIGALG_SHA1_WITH_RSA, true);
        final Set<X509Certificate> credentials = new HashSet<X509Certificate>();
        credentials.add(certificate);
        final Set<X500Principal> principals = new HashSet<X500Principal>();
        principals.add(certificate.getSubjectX500Principal());
        final AuthenticationToken adminTokenNoAuth = new X509CertificateAuthenticationToken(principals, credentials);
        for (final String logDeviceId : securityEventsAuditor.getQuerySupportingLogDevices()) {
            // SelectLogsWithNoCriteria
            try {
                securityEventsAuditor.selectAuditLogs(adminTokenNoAuth, 1, 10,
                        QueryCriteria.where().order(AuditLogEntry.FIELD_TIMESTAMP, QueryCriteria.ORDER_DESC), logDeviceId);
                assertTrue("should throw", false);
            } catch (AuthorizationDeniedException e) {
                // NOPMD
            }
            // AuditLogsValidation
            try {
                securityEventsAuditor.verifyLogsIntegrity(adminTokenNoAuth, new Date(), logDeviceId);
                assertTrue("should throw", false);
            } catch (AuthorizationDeniedException e) {
                // NOPMD
            }
            // ExportLogs
            try {
                CryptoToken cryptoToken = createTokenWithKeyPair();
                securityEventsAuditor.exportAuditLogs(adminTokenNoAuth, cryptoToken, new Date(), true, keyAlias, keyPairSignAlgorithm, logDeviceId);
                assertTrue("should throw", false);
            } catch (AuthorizationDeniedException e) {
                // NOPMD
            }
        }
    }

    @AfterClass
    public static void rmCryptoProvider() {
        CryptoProviderTools.removeBCProvider();
    }
}
